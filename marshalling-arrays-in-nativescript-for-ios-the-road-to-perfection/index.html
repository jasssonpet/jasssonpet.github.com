<!DOCTYPE HTML> <html> <head> <meta charset="utf-8"> <title>Marshalling Arrays in NativeScript for iOS - The Road to Perfection | Jason Zhekov&#39;s Blog</title> <meta name="author" content="Jason Zhekov"> <meta name="description" content="We at NativeScript take performance very seriously, so we try to improve it in each release. In this blog post I want to show you how marshalling between JavaScript arrays and Objective-C arrays has evolved between four different versions of the NativeScript Runtime for iOS."> <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"> <meta property="og:title" content="Marshalling Arrays in NativeScript for iOS - The Road to Perfection"> <meta property="og:site_name" content="Jason Zhekov&#39;s Blog"> <meta property="og:image" content="undefined"> <link href="/favicon.png" rel="icon"> <link rel="alternate" href="/atom.xml" title="Jason Zhekov&#39;s Blog" type="application/atom+xml"> <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css"> <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]--> </head></html> <body> <header id="header" class="inner"><div class="alignleft"> <h1><a href="/">Jason Zhekov&#39;s Blog</a></h1> <h2><a href="/"></a></h2> </div> <nav id="main-nav" class="alignright"> <ul> <li><a href="/">Home</a></li> <li><a href="/archives">Archives</a></li> <li><a href="/about-me">About</a></li> </ul> <div class="clearfix"></div> </nav> <div class="clearfix"></div></header> <div id="content" class="inner"> <div id="main-col"><div id="wrapper"><article class="post"> <div class="post-content"> <header> <div class="icon"></div> <time datetime="2015-09-20T21:00:00.000Z"><a href="/marshalling-arrays-in-nativescript-for-ios-the-road-to-perfection/">2015-09-21</a></time> <h1 class="title">Marshalling Arrays in NativeScript for iOS - The Road to Perfection</h1> </header> <div class="entry"> <p>We at <a href="https://www.nativescript.org/">NativeScript</a> take performance very seriously, so we try to improve it in each release. In this blog post I want to show you how marshalling between <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">JavaScript arrays</a> and <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSArray_Class/">Objective-C arrays</a> has evolved between four different versions of the <a href="https://github.com/NativeScript/ios-runtime">NativeScript Runtime for iOS</a>.</p> <a id="more"></a> <blockquote> <p>If you are not familiar with the idea of <em>marshalling</em> in general, please take a look at the docs: <a href="http://docs.nativescript.org/runtimes/ios/marshalling/Marshalling-Overview">Marshalling overview</a>.</p> </blockquote> <h2 id="v0-1-Creating-a-Deep-Copy-in-JavaScript"><a href="#v0-1-Creating-a-Deep-Copy-in-JavaScript" class="headerlink" title="v0.1 - Creating a Deep Copy in JavaScript"></a>v0.1 - Creating a Deep Copy in JavaScript</h2><p>In the very first release of NativeScript for iOS, if some method required <code>NSArray</code> as an argument, the user had to manually create a <code>NSArray</code> copy of the JavaScript array before calling the method:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">JSArrayToNSArray</span>(<span class="params">jsArray</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> nsArray = <span class="keyword">new</span> NSMutableArray();</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> currentJSObject <span class="keyword">of</span> jsArray) &#123;</div><div class="line">        <span class="comment">// Objective-C Arrays can't contain nil, so use NSNull object instead.</span></div><div class="line">        <span class="comment">// Marshalling of each element of the array is still done in native.</span></div><div class="line">        nsArray.addObject(currentJSObject != <span class="literal">null</span> ? currentJSObject : NSNull.null());</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> nsArray;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> textChecker = <span class="keyword">new</span> UITextChecker(); <span class="comment">// Shorthand for alloc/init</span></div><div class="line">textChecker.setIgnoredWords(JSArrayToNSArray([<span class="string">"NativeScript"</span>]));</div></pre></td></tr></table></figure></p> <p>This was the easiest way for us to implement it and in fact required no special native code. Needless to say, the code didn’t look as nice as it could and the performance of the testing apps suffered, but it was a <strong>great start to get something working</strong>.</p> <h2 id="v0-3-Creating-a-Deep-Copy-in-Native"><a href="#v0-3-Creating-a-Deep-Copy-in-Native" class="headerlink" title="v0.3 - Creating a Deep Copy in Native"></a>v0.3 - Creating a Deep Copy in Native</h2><p>After a complete rewrite and some more stabilizing to the code architecture, we were able to give some attention to details. In this version of NativeScript for iOS, the user could pass a plain JavaScript array to the above method. The bridge verified that it was a JavaScript array and implicitly handled the copying to <code>NSArray</code> in the Objective-C++ world:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSArray</span>* NativeScript::toObject(JSC::ExecState* execState, JSC::JSArray* jsArray) &#123;</div><div class="line">    <span class="built_in">NSMutableArray</span>* nsArray = [<span class="built_in">NSMutableArray</span> array];</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; jsArray-&gt;length(); ++i) &#123;</div><div class="line">        JSC::JSValue currentJSObject = jsArray-&gt;get(execState, i);</div><div class="line">        <span class="keyword">id</span> currentObject = NativeScript::toObject(execState, currentJSObject);</div><div class="line"></div><div class="line">        <span class="comment">// Objective-C Arrays can't contain nil, so use NSNull object instead.</span></div><div class="line">        [nsArray addObject:currentObject ?: [<span class="built_in">NSNull</span> null]];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> nsArray;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> textChecker = <span class="keyword">new</span> UITextChecker();</div><div class="line">textChecker.setIgnoredWords([<span class="string">"NativeScript"</span>]);</div></pre></td></tr></table></figure> <p>The first approach was still working, but this was the preferred way now. This way <strong>the code looked cleaner <em>and</em> there was a decent performance gain</strong>.</p> <h2 id="v1-0-Creating-a-Shallow-Copy"><a href="#v1-0-Creating-a-Shallow-Copy" class="headerlink" title="v1.0 - Creating a Shallow Copy"></a>v1.0 - Creating a Shallow Copy</h2><p>But we didn’t stop here. For the official release there was no longer a deep copy of JavaScript arrays, but a shallow one (<a href="https://github.com/NativeScript/ios-runtime/pull/64">#64</a> by <a href="https://github.com/fealebenpae">@fealebenpae</a>). Instead of copying the contents of the entire array, the native object now stored a strong reference to the JavaScript object. Marshalling of each element was done on demand.</p> <blockquote> <p>For this release not only JavaScript arrays could be implicitly marshalled to <code>NSArray</code>, but also any array-like object.</p> </blockquote> <p>According to the <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/Foundation/Classes/NSArray_Class/">Apple docs</a> a good way to change how <code>NSArray</code> stores its elements is by subclassing it. There are two required methods to be implemented which look something like the following:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">TNSJavaScriptArrayAdapter</span> : <span class="title">NSArray</span> </span>&#123;</div><div class="line">    JSC::Strong&lt;JSC::JSArray&gt; _jsArray;</div><div class="line">    JSC::ExecState* _execState;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)initWithJSArray:(JSC::JSArray*)jsArray execState:(JSC::ExecState*)execState &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</div><div class="line">        _jsArray = jsArray;</div><div class="line">        _execState = execState;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="built_in">NSUInteger</span>)count &#123;</div><div class="line">    <span class="keyword">return</span> _jsArray-&gt;length()</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)objectAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</div><div class="line">    JSC::JSValue currentJSObject = jsArray-&gt;get(_execState, index);</div><div class="line">    <span class="keyword">id</span> currentObject = NativeScript::toObject(execState, currentJSObject);</div><div class="line">    <span class="keyword">return</span> currentObject;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure></p> <p>There wasn’t so big of a performance gain this time, but this implementation <strong>reduced the memory footprint</strong> of our apps by skipping a copy of each array.</p> <h2 id="v1-2-Creating-a-Shallow-Copy-and-Implementing-NSFastEnumeration"><a href="#v1-2-Creating-a-Shallow-Copy-and-Implementing-NSFastEnumeration" class="headerlink" title="v1.2 - Creating a Shallow Copy and Implementing NSFastEnumeration"></a>v1.2 - Creating a Shallow Copy and Implementing <code>NSFastEnumeration</code></h2><p>The last change (so far) for marshalling JavaScript arrays to Objective-C was the implementation of the <a href="https://developer.apple.com/library/ios/documentation/Cocoa/Reference/NSFastEnumeration_protocol/"><code>NSFastEnumeration</code></a> protocol (<a href="https://github.com/NativeScript/ios-runtime/pull/222">#222</a> by <a href="https://github.com/fealebenpae">@fealebenpae</a>). You can learn more about <code>NSFastEnumeration</code> on <a href="http://nshipster.com/enumerators/">NSHipster</a>, but the essence is a single method named <code>countByEnumeratingWithState:objects:count:</code>, which the aforementioned <code>TNSJavaScriptArrayAdapter</code> implements:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSUInteger</span>)countByEnumeratingWithState:(<span class="built_in">NSFastEnumerationState</span> *)state objects:(<span class="keyword">id</span> [])stackbuf count:(<span class="built_in">NSUInteger</span>)len &#123;</div><div class="line">    <span class="comment">// Uninitialized</span></div><div class="line">    <span class="keyword">if</span> (state-&gt;state == <span class="number">0</span>) &#123;</div><div class="line">        state-&gt;state = <span class="number">1</span>;</div><div class="line">        state-&gt;mutationsPtr = reinterpret_cast&lt;<span class="keyword">unsigned</span> <span class="keyword">long</span>*&gt;(<span class="keyword">self</span>);</div><div class="line">        state-&gt;extra[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// Current index</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">NSUInteger</span> count = <span class="number">0</span>;</div><div class="line">    <span class="built_in">NSUInteger</span> currentIndex = state-&gt;extra[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span> (; count &lt; len &amp;&amp; currentIndex &lt; _jsArray-&gt;length(); currentIndex++, count++) &#123;</div><div class="line">        JSC::JSValue currentJSObject = jsArray-&gt;get(_execState, index);</div><div class="line">        <span class="keyword">id</span> currentObject = NativeScript::toObject(execState, currentJSObject);</div><div class="line">        *stackbuf++ = currentObject;</div><div class="line">    &#125;</div><div class="line">    state-&gt;extra[<span class="number">0</span>] = currentIndex;</div><div class="line"></div><div class="line">    state-&gt;itemsPtr = stackbuf;</div><div class="line">    <span class="keyword">return</span> count;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p> <p>The runtime is given a preallocated buffer on the stack, and fills it up accordingly. This way there are fewer method calls and objects can be loaded concurrently. In certain tests the same JavaScript code was <strong>up to 30x faster</strong> than in the previous release.</p> <blockquote> <p>Another thing that was made possible in this release of NativeScript for iOS was creating a <a href="http://docs.nativescript.org/runtimes/ios/how-to/ObjC-Subclassing">custom subclass of an Objective-C class in JavaScript</a> and implementing the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">JavaScript iteration protocol</a>. The runtime will look it up and will create a stub implementation of the <code>NSFastEnumeration</code> protocol which consumes the provided JavaScript one.</p> </blockquote> <h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>I’ve shown you only one aspect of the NativeScript Runtime, but you can see how it is constantly pushing the edges to be as fast as it can, while taking less memory and making the code easier to read.</p> <p>If you have any further suggestions or questions about NativeScript, don’t hesitate to <a href="https://github.com/NativeScript/ios-runtime/issues/new">open an issue on GitHub</a>.</p> </div> <footer> <div class="clearfix"></div> </footer> </div> </article></div></div> </div> <footer id="footer" class="inner"><div class="alignleft"> &copy; 2016 Jason Zhekov </div> <div class="clearfix"></div></footer> </body> 